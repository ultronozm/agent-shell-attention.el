;;; agent-shell-attention-test.el --- Tests for agent-shell-attention  -*- lexical-binding: t; -*-

(require 'ert)
(require 'cl-lib)

(setq load-prefer-newer t)

(add-to-list 'load-path (file-name-directory (or load-file-name buffer-file-name)))
(require 'agent-shell-attention)

;; Minimal stubs so we can create buffers that satisfy `(derived-mode-p 'agent-shell-mode)`.
(define-derived-mode agent-shell-mode fundamental-mode "agent-shell")
(defvar-local agent-shell--state nil)

(ert-deftest agent-shell-attention--apply-indicator-location-handles-nonlists ()
  (let ((orig-default-mlmi (default-value 'mode-line-misc-info))
        (orig-default-gms (default-value 'global-mode-string)))
    (unwind-protect
        (let ((mode-line-misc-info "misc")
              (global-mode-string "gms")
              (agent-shell-attention-indicator-location 'global-mode-string))
          (agent-shell-attention--apply-indicator-location)
          (should (listp global-mode-string))
          (should (member agent-shell-attention--mode-line global-mode-string))
          (should (listp mode-line-misc-info)))
      (setq-default mode-line-misc-info orig-default-mlmi)
      (setq-default global-mode-string orig-default-gms))))

(ert-deftest agent-shell-attention--message-skips-dead-buffers ()
  (let ((buffer (generate-new-buffer " *asa-dead*")))
    (kill-buffer buffer)
    (should-not (agent-shell-attention--message buffer "hi"))))

(ert-deftest agent-shell-attention--permission-pending-p-robustness ()
  (let ((buffer (generate-new-buffer " *asa-perm*")))
    (unwind-protect
        (with-current-buffer buffer
          (agent-shell-mode)
          ;; Non-map tool calls should not error.
          (setq agent-shell--state (let ((state (make-hash-table :test #'eq)))
                                     (puthash :tool-calls 123 state)
                                     state))
          (should-not (agent-shell-attention--permission-pending-p buffer))
          ;; Pending permission tool call should be detected.
          (let* ((tool-calls (make-hash-table :test #'equal))
                 (tool-call (let ((m (make-hash-table :test #'eq)))
                              (puthash :permission-request-id "req-1" m)
                              (puthash :status "pending" m)
                              m))
                 (state (make-hash-table :test #'eq)))
            (puthash "tool-1" tool-call tool-calls)
            (puthash :tool-calls tool-calls state)
            (setq agent-shell--state state)
            (should (agent-shell-attention--permission-pending-p buffer))))
      (when (buffer-live-p buffer)
        (kill-buffer buffer)))))

(ert-deftest agent-shell-attention-display-buffer-across-tabs-ignores-tab-errors ()
  (skip-unless (fboundp 'tab-bar-select-tab))
  (let ((tab-bar-mode t)
        (seen 0))
    (cl-letf (((symbol-function 'tab-bar-tabs)
               (lambda (&optional _frame)
                 (list '((ws . bogus)) '((ws . bogus)))))
              ((symbol-function 'tab-bar--current-tab)
               (lambda () '((ws . bogus))))
              ((symbol-function 'agent-shell-attention--tab-displays-buffer-p)
               (lambda (_tab _buffer)
                 (setq seen (1+ seen))
                 (= seen 2)))
              ((symbol-function 'tab-bar-select-tab)
               (lambda (_idx) (error "boom"))))
      (should-not (agent-shell-attention-display-buffer-across-tabs (current-buffer) nil)))))

(ert-deftest agent-shell-attention--active-entry-records-pending-first ()
  (let ((agent-shell-attention--pending (make-hash-table :test #'eq))
        (agent-shell-attention--busy (make-hash-table :test #'eq))
        (pending-buf (generate-new-buffer " *asa-pending*"))
        (busy-buf (generate-new-buffer " *asa-busy*")))
    (unwind-protect
        (progn
          (with-current-buffer pending-buf (agent-shell-mode))
          (with-current-buffer busy-buf (agent-shell-mode))
          (puthash pending-buf (cons "Need reply" 1.0) agent-shell-attention--pending)
          (puthash busy-buf 1 agent-shell-attention--busy)
          (let ((records (agent-shell-attention--active-entry-records)))
            (should (= (length records) 2))
            (should (eq (nth 0 (nth 0 records)) pending-buf))
            (should (eq (nth 2 (nth 0 records)) 'pending))
            (should (eq (nth 0 (nth 1 records)) busy-buf))
            (should-not (nth 1 (nth 1 records)))
            (should (eq (nth 2 (nth 1 records)) 'busy))))
      (when (buffer-live-p pending-buf) (kill-buffer pending-buf))
      (when (buffer-live-p busy-buf) (kill-buffer busy-buf)))))

(ert-deftest agent-shell-attention--completion-table-metadata-and-ordering ()
  (let ((agent-shell-attention--pending (make-hash-table :test #'eq))
        (agent-shell-attention--busy (make-hash-table :test #'eq))
        (agent-shell-attention-jump-show-groups nil)
        (pending-buf (generate-new-buffer " *asa-pending*"))
        (busy-buf (generate-new-buffer " *asa-busy*")))
    (unwind-protect
        (progn
          (with-current-buffer pending-buf (agent-shell-mode))
          (with-current-buffer busy-buf (agent-shell-mode))
          ;; Mark the same buffer both pending and busy; it should only appear once.
          (puthash pending-buf (cons "Need reply" 1.0) agent-shell-attention--pending)
          (puthash pending-buf 1 agent-shell-attention--busy)
          (puthash busy-buf 1 agent-shell-attention--busy)
          (let* ((records (agent-shell-attention--active-entry-records))
                 (candidates (agent-shell-attention--unique-candidates-with-status records))
                 (table (agent-shell-attention--completion-table candidates))
                 (meta (funcall table "" nil 'metadata))
                 (sort-fn (cdr (assq 'display-sort-function (cdr meta)))))
            (should (equal (car meta) 'metadata))
            (should (functionp sort-fn))
            (should (assq 'affixation-function (cdr meta)))
            (should (assq 'annotation-function (cdr meta)))
            (let ((all (funcall table "" nil t)))
              (should (= (length all) 2))
              ;; Pending should come before busy-only, even if the input list is reversed.
              (let ((sorted (funcall sort-fn (reverse all))))
                (should (string-match-p "Need reply" (car sorted)))))))
      (when (buffer-live-p pending-buf) (kill-buffer pending-buf))
      (when (buffer-live-p busy-buf) (kill-buffer busy-buf)))))

(ert-deftest agent-shell-attention--completion-table-group-function-protocol ()
  (let ((agent-shell-attention--pending (make-hash-table :test #'eq))
        (agent-shell-attention--busy (make-hash-table :test #'eq))
        (agent-shell-attention-jump-show-groups t)
        (pending-buf (generate-new-buffer " *asa-pending*")))
    (unwind-protect
        (progn
          (with-current-buffer pending-buf (agent-shell-mode))
          (puthash pending-buf (cons "Need reply" 1.0) agent-shell-attention--pending)
          (let* ((records (agent-shell-attention--active-entry-records))
                 (candidates (agent-shell-attention--unique-candidates-with-status records))
                 (table (agent-shell-attention--completion-table candidates))
                 (meta (funcall table "" nil 'metadata))
                 (group-fn (cdr (assq 'group-function (cdr meta))))
                 (display (caar candidates)))
            (should (functionp group-fn))
            (should (stringp (funcall group-fn display nil)))
            (should (equal (funcall group-fn display t) display))))
      (when (buffer-live-p pending-buf) (kill-buffer pending-buf)))))

(ert-deftest agent-shell-attention--around-send-command-supports-shell-buffer ()
  (let ((agent-shell-attention--pending (make-hash-table :test #'eq))
        (agent-shell-attention--busy (make-hash-table :test #'eq))
        (buffer (generate-new-buffer " *asa-send*"))
        (seen-buffer nil)
        (send-called nil)
        (request-decorated nil))
    (unwind-protect
        (progn
          (with-current-buffer buffer
            (agent-shell-mode))
          (cl-letf (((symbol-function 'agent-shell-attention--clear-buffer)
                     (lambda (_buffer) nil))
                    ((symbol-function 'agent-shell-attention--mark-busy)
                     (lambda (buf)
                       (setq seen-buffer buf)))
                    ((symbol-function 'agent-shell-attention--clear-busy)
                     (lambda (_buffer) nil))
                    ((symbol-function 'agent-shell-attention--decorate-request)
                     (lambda (_buffer request-args)
                       (setq request-decorated t)
                       request-args))
                    ((symbol-function 'acp-send-request)
                     (lambda (&rest _request-args)
                       'acp-ok))
                    ((symbol-function 'fake-orig)
                     (lambda (&rest _args)
                       (setq send-called t)
                       (acp-send-request :request 'dummy)
                       'orig-ok)))
            (should
             (eq (agent-shell-attention--around-send-command
                  #'fake-orig :prompt "hello" :shell-buffer buffer)
                 'orig-ok))
            (should send-called)
            (should (eq seen-buffer buffer))
            (should request-decorated)))
      (when (buffer-live-p buffer)
        (kill-buffer buffer)))))

(provide 'agent-shell-attention-test)

;;; agent-shell-attention-test.el ends here
